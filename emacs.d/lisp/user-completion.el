;;; user-completion.el --- -*- lexical-binding: t; -*-

;;; Commentary:

;; Contains some custom completion stuff (like line-completion)

;;; Code:
(require 'cl-lib)
(require 'company)
(require 'hippie-exp)

(defun user-hippie-expand-completions (&optional hippie-expand-function)
  "Return the full list of possible completions generated by `hippie-expand'.
The `HIPPIE-EXPAND-FUNCTION' can be generated with `make-hippie-expand-function'."
  (let ((this-command 'my-hippie-expand-completions)
        (last-command last-command)
        (buffer-modified (buffer-modified-p))
        (hippie-expand-function (or hippie-expand-function 'hippie-expand)))
    (while (progn
             (funcall hippie-expand-function nil)
             (setq last-command 'my-hippie-expand-completions)
             (not (equal he-num -1))))
    ;; Evaluating the completions modifies the buffer, however we will finish
    ;; up in the same state that we began.
    (set-buffer-modified-p buffer-modified)
    ;; Provide the options in the order in which they are normally generated.
    (delete he-search-string (reverse he-tried-table))))

(defun company-line-backend (command &optional _arg &rest _ignored)
  "A company backend for line completion (using `hippie-expand').
`COMMAND' - which command (see writing company backends for more details)
we should handle."
  (interactive (list 'interactive))
  (cl-case command
    (interactive (company-begin-backend 'company-line-backend))
    (prefix (buffer-substring-no-properties (line-beginning-position) (point)))
    (candidates (user-hippie-expand-completions
                 (make-hippie-expand-function '(try-expand-line))))))

(defun user-complete-line ()
  "Start a line completion using `company'."
  (interactive)
  (company-begin-backend 'company-line-backend))

(provide 'user-completion)
;;; user-completion ends here
